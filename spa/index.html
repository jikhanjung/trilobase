<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trilobase</title>
    <link href="./bootstrap.min.css" rel="stylesheet">
    <link href="./bootstrap-icons.css" rel="stylesheet">
    <style>
/* Trilobase Web Interface Styles */

:root {
    --tree-indent: 20px;
    --panel-bg: #f8f9fa;
    --border-color: #dee2e6;
    --hover-bg: #e9ecef;
    --selected-bg: #0d6efd;
    --selected-color: #fff;
    --tabs-height: 42px;
}

html, body {
    height: 100%;
    margin: 0;
    overflow: hidden;
}

/* View Tabs Bar (wrapper for tabs + search) */
.view-tabs-bar {
    display: flex;
    align-items: stretch;
    background: #f8f9fa;
    border-bottom: 1px solid var(--border-color);
    height: var(--tabs-height);
}

/* View Tabs */
.view-tabs {
    display: flex;
    padding: 0 10px;
    height: 100%;
    align-items: stretch;
    overflow-x: auto;
    flex: 1;
    min-width: 0;
}

.view-tabs:empty {
    display: none;
}

.view-tabs-bar:not(:has(.view-tab)) {
    display: none;
}

.view-tab {
    border: none;
    background: none;
    padding: 8px 16px;
    font-size: 0.85rem;
    color: #6c757d;
    cursor: pointer;
    border-bottom: 2px solid transparent;
    white-space: nowrap;
    transition: color 0.2s, border-color 0.2s;
}

.view-tab:hover {
    color: #495057;
    background: #e9ecef;
}

.view-tab.active {
    color: #0d6efd;
    border-bottom-color: #0d6efd;
    font-weight: 500;
}

.view-tab i {
    margin-right: 4px;
}

/* View Containers */
.view-container {
    height: calc(100vh - 56px);
}

.view-tabs-bar:has(.view-tab) ~ .view-container {
    height: calc(100vh - 56px - var(--tabs-height));
}

.main-content {
    height: 100%;
    padding: 0;
}

.main-content > .row {
    height: 100%;
    margin: 0;
}

/* Panel Styles */
.tree-panel, .list-panel {
    height: 100%;
    padding: 0;
    display: flex;
    flex-direction: column;
}

.tree-panel {
    background: var(--panel-bg);
    border-right: 1px solid var(--border-color);
}

.panel-header {
    padding: 10px 15px;
    background: #fff;
    border-bottom: 1px solid var(--border-color);
    flex-shrink: 0;
}

.panel-header h5 {
    margin: 0;
    font-size: 1rem;
    color: #495057;
}

.panel-header .btn-group-sm .btn {
    padding: 2px 6px;
    font-size: 0.8rem;
}

/* Tree Container */
.tree-container {
    flex: 1;
    overflow-y: auto;
    padding: 10px;
}

/* Tree Node Styles */
.tree-node {
    user-select: none;
}

.tree-node-content {
    display: flex;
    align-items: center;
    padding: 4px 8px;
    cursor: pointer;
    border-radius: 4px;
    white-space: nowrap;
}

.tree-node-content:hover {
    background: var(--hover-bg);
}

.tree-node-content.selected {
    background: var(--selected-bg);
    color: var(--selected-color);
}

.tree-toggle {
    width: 20px;
    text-align: center;
    color: #6c757d;
}

.tree-toggle:empty::before {
    content: '';
    display: inline-block;
    width: 20px;
}

.tree-icon {
    margin-right: 6px;
    color: #ffc107;
}

.tree-node-content.selected .tree-icon {
    color: #fff;
}

.tree-label {
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
}

.tree-count {
    font-size: 0.8rem;
    color: #6c757d;
    margin-left: 8px;
}

.tree-node-content.selected .tree-count {
    color: rgba(255,255,255,0.8);
}

.tree-children {
    margin-left: var(--tree-indent);
}

.tree-children.collapsed {
    display: none;
}

/* Info icon */
.tree-info {
    margin-left: 8px;
    color: #6c757d;
    opacity: 0;
    transition: opacity 0.2s;
    cursor: pointer;
}

.tree-node-content:hover .tree-info {
    opacity: 1;
}

.tree-info:hover {
    color: #0d6efd;
}

.tree-node-content.selected .tree-info {
    color: rgba(255,255,255,0.7);
}

.tree-node-content.selected .tree-info:hover {
    color: #fff;
}

/* Children list in modal */
.children-list li {
    padding: 4px 0;
    border-bottom: 1px solid #f0f0f0;
}

.children-list li:last-child {
    border-bottom: none;
}

.children-list li.clickable {
    cursor: pointer;
    padding: 4px 6px;
    border-radius: 4px;
}

.children-list li.clickable:hover {
    background-color: var(--hover-bg);
}

/* Rank Colors */
.rank-Class .tree-icon { color: #dc3545; }
.rank-Order .tree-icon { color: #fd7e14; }
.rank-Suborder .tree-icon { color: #ffc107; }
.rank-Superfamily .tree-icon { color: #20c997; }
.rank-Family .tree-icon { color: #0dcaf0; }

/* List Container */
.list-container {
    flex: 1;
    overflow-y: auto;
    padding: 0 15px 15px 15px;
}

.empty-state {
    text-align: center;
    color: #6c757d;
    padding: 50px 20px;
}

.empty-state i {
    font-size: 3rem;
    margin-bottom: 15px;
}

/* Genera Stats */
.genera-stats {
    font-size: 0.85rem;
    padding: 0 5px;
}

/* Genus Table */
.genus-table {
    width: 100%;
    border-collapse: collapse;
}

.genus-table th {
    position: sticky;
    top: 0;
    background-color: #fff;
    border-bottom: 2px solid var(--border-color);
    padding: 10px;
    text-align: left;
    font-weight: 600;
    z-index: 10;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

.genus-table td {
    padding: 8px 10px;
    border-bottom: 1px solid var(--border-color);
}

.genus-table tr {
    cursor: pointer;
}

.genus-table tr:hover {
    background: var(--hover-bg);
}

.genus-table tr.invalid {
    color: #6c757d;
    font-style: italic;
}

.genus-name {
    font-weight: 500;
}

.genus-name i {
    font-style: italic;
}

/* Table View (manifest-driven) */
.table-view-content {
    display: flex;
    flex-direction: column;
    height: 100%;
    padding: 0;
}

.table-view-header {
    padding: 12px 20px 8px;
    flex-shrink: 0;
}

.table-view-header h5 {
    margin: 0 0 4px;
    font-size: 1rem;
    color: #495057;
}

.table-view-header p {
    font-size: 0.85rem;
}

.table-view-toolbar {
    padding: 0 20px 8px;
    flex-shrink: 0;
}

.table-view-search {
    position: relative;
    max-width: 300px;
}

.table-view-search i {
    position: absolute;
    left: 10px;
    top: 50%;
    transform: translateY(-50%);
    color: #6c757d;
    font-size: 0.85rem;
}

.table-view-search input {
    padding-left: 32px;
}

.table-view-body {
    flex: 1;
    overflow-y: auto;
    padding: 0 20px 20px;
}

.table-view-stats {
    font-size: 0.85rem;
    padding: 0 5px;
}

/* Manifest Table */
.manifest-table {
    width: 100%;
    border-collapse: collapse;
}

.manifest-table th {
    position: sticky;
    top: 0;
    background-color: #fff;
    border-bottom: 2px solid var(--border-color);
    padding: 10px;
    text-align: left;
    font-weight: 600;
    font-size: 0.9rem;
    white-space: nowrap;
    z-index: 10;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

.manifest-table th.sortable {
    cursor: pointer;
    user-select: none;
}

.manifest-table th.sortable:hover {
    background: #f8f9fa;
}

.manifest-table th i {
    font-size: 0.7rem;
    margin-left: 4px;
    color: #0d6efd;
}

.manifest-table td {
    padding: 8px 10px;
    border-bottom: 1px solid var(--border-color);
    font-size: 0.9rem;
}

.manifest-table tbody tr[onclick] {
    cursor: pointer;
}

.manifest-table tbody tr:hover {
    background: var(--hover-bg);
}

/* Modal Styles */
.detail-section {
    margin-bottom: 20px;
}

.detail-section h6 {
    color: #495057;
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 5px;
    margin-bottom: 10px;
}

.detail-grid {
    display: grid;
    grid-template-columns: 150px 1fr;
    gap: 8px;
}

.detail-label {
    font-weight: 500;
    color: #6c757d;
}

.detail-value {
    color: #212529;
}

.detail-value.invalid {
    color: #dc3545;
}

.badge-synonym {
    font-size: 0.75rem;
    margin-right: 5px;
}

.synonym-link {
    color: #0d6efd;
    text-decoration: none;
}

.synonym-link:hover {
    text-decoration: underline;
}

.detail-link {
    color: #0d6efd;
    cursor: pointer;
}

.detail-link:hover {
    text-decoration: underline;
}

.genera-list {
    max-height: 400px;
    overflow-y: auto;
}

.raw-entry {
    background: #f8f9fa;
    padding: 10px;
    border-radius: 4px;
    font-family: monospace;
    font-size: 0.85rem;
    white-space: pre-wrap;
    word-break: break-word;
}

/* Annotation Section (My Notes) */
.annotation-section {
    background: #fffde7;
    border-radius: 8px;
    padding: 12px;
    margin-top: 8px;
}

.annotation-section h6 {
    color: #795548;
    border-bottom: 1px solid #f0e68c;
    padding-bottom: 5px;
    margin-bottom: 10px;
}

.annotation-item {
    border-bottom: 1px solid #f0e68c;
    padding: 8px 0;
}

.annotation-item:last-child {
    border-bottom: none;
}

.annotation-form textarea {
    width: 100%;
}

/* Chart View (ICS Chronostratigraphic Chart) */
.chart-view-content {
    display: flex;
    flex-direction: column;
    height: 100%;
    padding: 0;
}

.chart-view-header {
    padding: 12px 20px 8px;
    flex-shrink: 0;
}

.chart-view-header h5 {
    margin: 0 0 4px;
    font-size: 1rem;
    color: #495057;
}

.chart-view-header p {
    font-size: 0.85rem;
}

.chart-view-body {
    flex: 1;
    overflow-y: auto;
    padding: 0 20px 20px;
}

.ics-chart {
    width: 100%;
    border-collapse: collapse;
    table-layout: fixed;
}

.ics-chart thead th {
    position: sticky;
    top: 0;
    background-color: #495057;
    color: #fff;
    padding: 8px 6px;
    text-align: center;
    font-weight: 600;
    font-size: 0.8rem;
    border: 1px solid #343a40;
    z-index: 10;
    white-space: nowrap;
}

.ics-chart td {
    padding: 4px 6px;
    text-align: center;
    vertical-align: middle;
    cursor: pointer;
    border: 1px solid rgba(0,0,0,0.2);
    font-size: 0.8rem;
    font-weight: 500;
    line-height: 1.2;
    word-wrap: break-word;
}

.ics-chart td:hover {
    filter: brightness(0.9);
}

.ics-chart .ics-age {
    background-color: #f8f9fa;
    color: #495057;
    font-size: 0.75rem;
    cursor: default;
    width: 60px;
    text-align: right;
    padding-right: 8px;
}

.ics-chart .ics-age:hover {
    filter: none;
}

/* Color Chip */
.color-chip {
    display: inline-block;
    width: 16px;
    height: 16px;
    border-radius: 3px;
    border: 1px solid rgba(0,0,0,0.15);
    vertical-align: middle;
}

/* Loading */
.loading {
    text-align: center;
    padding: 20px;
    color: #6c757d;
}

/* Scrollbar */
.tree-container::-webkit-scrollbar,
.list-container::-webkit-scrollbar,
.table-view-body::-webkit-scrollbar,
.chart-view-body::-webkit-scrollbar {
    width: 8px;
}

.tree-container::-webkit-scrollbar-thumb,
.list-container::-webkit-scrollbar-thumb,
.table-view-body::-webkit-scrollbar-thumb,
.chart-view-body::-webkit-scrollbar-thumb {
    background: #ced4da;
    border-radius: 4px;
}

.tree-container::-webkit-scrollbar-thumb:hover,
.list-container::-webkit-scrollbar-thumb:hover,
.table-view-body::-webkit-scrollbar-thumb:hover,
.chart-view-body::-webkit-scrollbar-thumb:hover {
    background: #adb5bd;
}

/* Global Search */
.global-search-container {
    position: relative;
    display: flex;
    align-items: center;
    padding: 0 12px;
    flex-shrink: 0;
}

.global-search-wrapper {
    position: relative;
    display: flex;
    align-items: center;
    width: 260px;
    background: #fff;
    border: 1px solid var(--border-color);
    border-radius: 6px;
    padding: 0 8px;
    height: 30px;
    transition: border-color 0.2s, box-shadow 0.2s;
}

.global-search-wrapper:focus-within {
    border-color: #86b7fe;
    box-shadow: 0 0 0 3px rgba(13, 110, 253, 0.15);
}

.global-search-wrapper > i {
    color: #adb5bd;
    font-size: 0.8rem;
    flex-shrink: 0;
}

.global-search-wrapper input {
    border: none;
    outline: none;
    background: transparent;
    font-size: 0.82rem;
    padding: 0 8px;
    flex: 1;
    min-width: 0;
    color: #212529;
}

.global-search-wrapper input::placeholder {
    color: #adb5bd;
    font-size: 0.8rem;
}

.global-search-shortcut {
    font-size: 0.65rem;
    color: #adb5bd;
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 3px;
    padding: 1px 4px;
    flex-shrink: 0;
    font-family: inherit;
    line-height: 1;
}

/* Search Results Dropdown */
.global-search-results {
    display: none;
    position: absolute;
    top: calc(100% + 4px);
    right: 0;
    width: 480px;
    max-height: 520px;
    overflow-y: auto;
    background: #fff;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
    z-index: 1050;
    padding: 4px 0;
}

.global-search-results.visible {
    display: block;
}

.search-category-header {
    display: flex;
    align-items: center;
    padding: 8px 12px 4px;
    font-size: 0.72rem;
    font-weight: 600;
    color: #6c757d;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    border-top: 1px solid #f0f0f0;
}

.search-category-header:first-child {
    border-top: none;
}

.search-category-header i {
    margin-right: 6px;
    font-size: 0.8rem;
}

.search-category-header .search-cat-count {
    margin-left: auto;
    font-weight: 400;
    color: #adb5bd;
}

.search-result-item {
    display: flex;
    align-items: center;
    padding: 6px 12px;
    cursor: pointer;
    font-size: 0.85rem;
    color: #212529;
    transition: background 0.1s;
}

.search-result-item:hover,
.search-result-item.highlighted {
    background: #e9ecef;
}

.search-result-item .search-result-main {
    flex: 1;
    min-width: 0;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.search-result-item .search-result-meta {
    font-size: 0.75rem;
    color: #6c757d;
    margin-left: 8px;
    flex-shrink: 0;
    max-width: 180px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.search-result-item mark {
    background: #fff3cd;
    color: inherit;
    padding: 0 1px;
    border-radius: 2px;
}

.search-more-item {
    padding: 4px 12px;
    font-size: 0.78rem;
    color: #0d6efd;
    cursor: pointer;
}

.search-more-item:hover {
    background: #e9ecef;
}

.search-status {
    padding: 12px;
    text-align: center;
    color: #6c757d;
    font-size: 0.85rem;
}

.search-status i {
    margin-right: 4px;
}
    </style>
    <script>
    // Auto-detect API base: file:// protocol uses localhost, HTTP uses same origin
    var API_BASE = window.location.protocol === 'file:' ? 'http://localhost:8080' : '';
    </script>
</head>
<body>
    <!-- Header -->
    <nav class="navbar navbar-dark bg-dark">
        <div class="container-fluid">
            <span class="navbar-brand mb-0 h1">
                <i class="bi bi-bug"></i> Trilobase
                <small class="text-white-50" style="font-size: 0.55em; margin-left: 6px; font-weight: 300;">A SCODA Package</small>
                <small id="navbar-pkg-name" class="text-white-50" style="font-size: 0.6em; margin-left: 8px;"></small>
            </span>
        </div>
    </nav>
    <!-- View Tabs + Global Search -->
    <div class="view-tabs-bar">
        <div class="view-tabs" id="view-tabs"></div>
        <div class="global-search-container">
            <div class="global-search-wrapper">
                <i class="bi bi-search"></i>
                <input type="text" id="global-search-input"
                       placeholder="Search genera, formations, references..."
                       autocomplete="off">
                <kbd class="global-search-shortcut">Ctrl+K</kbd>
            </div>
            <div class="global-search-results" id="global-search-results"></div>
        </div>
    </div>

    <!-- View: Tree (default, existing layout) -->
    <div class="view-container" id="view-tree">
        <div class="container-fluid main-content">
            <div class="row h-100">
                <!-- Left Panel: Tree View -->
                <div class="col-md-4 col-lg-3 tree-panel">
                    <div class="panel-header d-flex justify-content-between align-items-center">
                        <h5 class="mb-0"><i class="bi bi-folder-tree"></i> Taxonomy</h5>
                        <div class="btn-group btn-group-sm">
                            <button class="btn btn-outline-secondary" onclick="expandAll()" title="Expand All">
                                <i class="bi bi-chevron-expand"></i>
                            </button>
                            <button class="btn btn-outline-secondary" onclick="collapseAll()" title="Collapse All">
                                <i class="bi bi-chevron-contract"></i>
                            </button>
                        </div>
                    </div>
                    <div class="tree-container" id="tree-container">
                        <div class="loading">Loading...</div>
                    </div>
                </div>

                <!-- Right Panel: Genus List -->
                <div class="col-md-8 col-lg-9 list-panel">
                    <div class="panel-header" id="list-header">
                        <h5><i class="bi bi-list-ul"></i> Select a Family</h5>
                    </div>
                    <div class="list-container" id="list-container">
                        <div class="empty-state">
                            <i class="bi bi-arrow-left-circle"></i>
                            <p>Select a Family from the tree to view genera</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- View: Table (for manifest-driven table views) -->
    <div class="view-container" id="view-table" style="display: none;">
        <div class="container-fluid table-view-content">
            <div class="table-view-header" id="table-view-header"></div>
            <div class="table-view-toolbar" id="table-view-toolbar"></div>
            <div class="table-view-body" id="table-view-body">
                <div class="loading">Loading...</div>
            </div>
        </div>
    </div>

    <!-- View: Chart (ICS Chronostratigraphic Chart) -->
    <div class="view-container" id="view-chart" style="display: none;">
        <div class="container-fluid chart-view-content">
            <div class="chart-view-header" id="chart-view-header"></div>
            <div class="chart-view-body" id="chart-view-body">
                <div class="loading">Loading...</div>
            </div>
        </div>
    </div>

    <!-- Genus Detail Modal -->
    <div class="modal fade" id="genusModal" tabindex="-1">
        <div class="modal-dialog modal-lg modal-dialog-scrollable">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="genusModalTitle">Genus Detail</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body" id="genusModalBody">
                    <div class="loading">Loading...</div>
                </div>
            </div>
        </div>
    </div>

    <script src="./bootstrap.bundle.min.js"></script>
    <script>
/**
 * Trilobase Reference SPA
 * Full-featured frontend with API_BASE support for standalone deployment
 */

// API base URL (set by index.html script tag, defaults to same-origin)
if (typeof API_BASE === 'undefined') var API_BASE = '';

// State
let selectedFamilyId = null;
let genusModal = null;
let currentGenera = [];  // Store current genera for filtering
let showOnlyValid = true;  // Filter state

// Manifest state
let manifest = null;
let currentView = 'taxonomy_tree';
let tableViewData = [];
let tableViewSort = null;
let tableViewSearchTerm = '';

// Shared query cache — fetch once, reuse across search index + tab views
let queryCache = {};

// Initialize
document.addEventListener('DOMContentLoaded', async () => {
    genusModal = new bootstrap.Modal(document.getElementById('genusModal'));
    await loadManifest();

    // Determine initial view from manifest (default to taxonomy_tree for legacy)
    if (manifest && manifest.views) {
        const viewKeys = Object.keys(manifest.views).filter(k => manifest.views[k].type !== 'detail');
        if (manifest.default_view && manifest.views[manifest.default_view]) {
            currentView = manifest.default_view;
        } else if (viewKeys.length > 0 && !manifest.views['taxonomy_tree']) {
            currentView = viewKeys[0];
        }
        // Rebuild tabs with correct currentView
        buildViewTabs();
        switchToView(currentView);
    } else {
        // Legacy fallback: no manifest, just load tree
        loadTree();
    }

    // Global search — preload all data into shared cache
    initGlobalSearch();
    preloadSearchIndex();
});

/**
 * Load UI manifest from API (graceful degradation if unavailable)
 */
async function loadManifest() {
    try {
        const response = await fetch(API_BASE + '/api/manifest');
        if (!response.ok) return;
        const data = await response.json();
        manifest = data.manifest;
        buildViewTabs();

        // Show package name in navbar
        if (data.package && data.package.name) {
            const el = document.getElementById('navbar-pkg-name');
            if (el) el.textContent = `${data.package.name} v${data.package.version}`;
        }
    } catch (error) {
        // Graceful degradation: manifest unavailable, use existing UI
    }
}

/**
 * Fetch a named query with caching. Returns cached rows if available.
 */
async function fetchQuery(queryName) {
    if (queryCache[queryName]) return queryCache[queryName];
    const url = API_BASE + `/api/queries/${queryName}/execute`;
    const response = await fetch(url);
    if (!response.ok) throw new Error(`Query failed: ${queryName}`);
    const data = await response.json();
    queryCache[queryName] = data.rows || [];
    return queryCache[queryName];
}

/**
 * Build view tabs from manifest
 */
function buildViewTabs() {
    if (!manifest || !manifest.views) return;

    const tabsContainer = document.getElementById('view-tabs');
    let html = '';

    for (const [key, view] of Object.entries(manifest.views)) {
        // Skip detail type views (they're not top-level tabs)
        if (view.type === 'detail') continue;

        const isActive = key === currentView;
        const icon = view.icon || 'bi-square';
        html += `<button class="view-tab ${isActive ? 'active' : ''}"
                         data-view="${key}" onclick="switchToView('${key}')">
                    <i class="bi ${icon}"></i> ${view.title}
                 </button>`;
    }

    tabsContainer.innerHTML = html;
}

/**
 * Switch between views
 */
function switchToView(viewKey) {
    if (!manifest || !manifest.views[viewKey]) return;

    currentView = viewKey;
    const view = manifest.views[viewKey];

    // Update tab active state
    document.querySelectorAll('.view-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.view === viewKey);
    });

    // Show/hide view containers
    const treeContainer = document.getElementById('view-tree');
    const tableContainer = document.getElementById('view-table');
    const chartContainer = document.getElementById('view-chart');

    treeContainer.style.display = 'none';
    tableContainer.style.display = 'none';
    chartContainer.style.display = 'none';

    if (view.type === 'tree') {
        treeContainer.style.display = '';
        loadTree();
    } else if (view.type === 'table') {
        tableContainer.style.display = '';
        tableViewSort = view.default_sort || null;
        tableViewSearchTerm = '';
        renderTableView(viewKey);
    } else if (view.type === 'chart') {
        chartContainer.style.display = '';
        renderChronostratChart(viewKey);
    }
}

/**
 * Render a table view using manifest definition and query execution
 */
async function renderTableView(viewKey) {
    const view = manifest.views[viewKey];
    if (!view || view.type !== 'table') return;

    const header = document.getElementById('table-view-header');
    const toolbar = document.getElementById('table-view-toolbar');
    const body = document.getElementById('table-view-body');

    // Header
    header.innerHTML = `<h5><i class="bi ${view.icon || 'bi-table'}"></i> ${view.title}</h5>
                        <p class="text-muted mb-0">${view.description || ''}</p>`;

    // Toolbar (search)
    if (view.searchable) {
        toolbar.innerHTML = `<div class="table-view-search">
            <i class="bi bi-search"></i>
            <input type="text" class="form-control form-control-sm"
                   placeholder="Search..." id="table-search-input"
                   oninput="onTableSearch(this.value)" value="${tableViewSearchTerm}">
        </div>`;
    } else {
        toolbar.innerHTML = '';
    }

    // Load data (from shared cache or fetch)
    body.innerHTML = '<div class="loading">Loading...</div>';

    try {
        tableViewData = await fetchQuery(view.source_query);
        renderTableViewRows(viewKey);
    } catch (error) {
        body.innerHTML = `<div class="text-danger">Error: ${error.message}</div>`;
    }
}

/**
 * Render table rows with current sort and search applied
 */
function renderTableViewRows(viewKey) {
    const view = manifest.views[viewKey];
    if (!view || !view.columns) return;

    const body = document.getElementById('table-view-body');
    let rows = [...tableViewData];

    // Apply search
    if (tableViewSearchTerm) {
        const term = tableViewSearchTerm.toLowerCase();
        const searchableCols = view.columns.filter(c => c.searchable).map(c => c.key);
        rows = rows.filter(row =>
            searchableCols.some(key => {
                const val = row[key];
                return val && String(val).toLowerCase().includes(term);
            })
        );
    }

    // Apply sort
    if (tableViewSort) {
        const { key, direction } = tableViewSort;
        rows.sort((a, b) => {
            let va = a[key], vb = b[key];
            if (va == null) va = '';
            if (vb == null) vb = '';
            if (typeof va === 'number' && typeof vb === 'number') {
                return direction === 'asc' ? va - vb : vb - va;
            }
            va = String(va).toLowerCase();
            vb = String(vb).toLowerCase();
            if (va < vb) return direction === 'asc' ? -1 : 1;
            if (va > vb) return direction === 'asc' ? 1 : -1;
            return 0;
        });
    }

    // Build table
    let html = `<div class="table-view-stats text-muted mb-2">${rows.length} of ${tableViewData.length} records</div>`;
    html += '<table class="manifest-table"><thead><tr>';

    view.columns.forEach(col => {
        const sortIcon = getSortIcon(col.key);
        const sortable = col.sortable ? `onclick="onTableSort('${viewKey}', '${col.key}')"` : '';
        const sortableClass = col.sortable ? 'sortable' : '';
        html += `<th class="${sortableClass}" ${sortable}>${col.label} ${sortIcon}</th>`;
    });
    html += '</tr></thead><tbody>';

    // Manifest-driven click handler
    const rowClick = view.on_row_click;
    const getClick = rowClick
        ? (row) => `onclick="openDetail('${rowClick.detail_view}', ${row[rowClick.id_key]})"`
        : null;

    if (rows.length === 0) {
        html += `<tr><td colspan="${view.columns.length}" class="text-center text-muted py-4">No matching records</td></tr>`;
    } else {
        rows.forEach(row => {
            const clickAttr = getClick ? getClick(row) : '';
            html += `<tr ${clickAttr}>`;
            view.columns.forEach(col => {
                let val = row[col.key];
                if (col.type === 'color') {
                    const color = val || '';
                    val = color ? `<span class="color-chip" style="background-color:${color}" title="${color}"></span> ${color}` : '';
                } else if (col.type === 'boolean') {
                    val = val ? 'Yes' : 'No';
                } else if (val == null) {
                    val = '';
                }
                const italic = col.italic ? `<i>${val}</i>` : val;
                html += `<td>${italic}</td>`;
            });
            html += '</tr>';
        });
    }

    html += '</tbody></table>';
    body.innerHTML = html;
}

/**
 * Get sort indicator icon for a column
 */
function getSortIcon(key) {
    if (!tableViewSort || tableViewSort.key !== key) return '';
    return tableViewSort.direction === 'asc'
        ? '<i class="bi bi-caret-up-fill"></i>'
        : '<i class="bi bi-caret-down-fill"></i>';
}

/**
 * Handle table column sort click
 */
function onTableSort(viewKey, key) {
    if (tableViewSort && tableViewSort.key === key) {
        tableViewSort.direction = tableViewSort.direction === 'asc' ? 'desc' : 'asc';
    } else {
        tableViewSort = { key, direction: 'asc' };
    }
    renderTableViewRows(viewKey);
}

/**
 * Handle table search input
 */
function onTableSearch(value) {
    tableViewSearchTerm = value;
    renderTableViewRows(currentView);
}

/**
 * Render ICS Chronostratigraphic Chart as a hierarchical colored table
 */
async function renderChronostratChart(viewKey) {
    const view = manifest.views[viewKey];
    if (!view) return;

    const opts = view.chart_options || {};

    const header = document.getElementById('chart-view-header');
    const body = document.getElementById('chart-view-body');

    header.innerHTML = `<h5><i class="bi ${view.icon || 'bi-clock-history'}"></i> ${view.title}</h5>
                        <p class="text-muted mb-0">${view.description || ''}</p>`;

    body.innerHTML = '<div class="loading">Loading...</div>';

    try {
        const rows = await fetchQuery(view.source_query);

        // Build rank→column mapping from manifest
        const rankColumns = opts.rank_columns || [
            {rank: 'Eon'}, {rank: 'Era'}, {rank: 'Period'},
            {rank: 'Sub-Period'}, {rank: 'Epoch'}, {rank: 'Age'}
        ];
        const rankColMap = {};
        rankColumns.forEach((rc, i) => { rankColMap[rc.rank] = i; });
        const colCount = rankColumns.length + 1; // +1 for value column

        // Build tree from flat data
        const tree = buildChartTree(rows, opts);
        // Compute leaf counts for rowspan
        tree.forEach(node => computeLeafCount(node));
        // Collect leaf rows (each row = root→leaf path)
        const leafRows = [];
        tree.forEach(node => collectLeafRows(node, [], leafRows, 0, rankColMap, opts));

        // Render HTML table
        body.innerHTML = renderChartHTML(leafRows, opts);
    } catch (error) {
        body.innerHTML = `<div class="text-danger">Error: ${error.message}</div>`;
    }
}

/**
 * Build tree structure from flat ICS data (manifest-driven).
 * Nodes with ranks in skip_ranks are skipped; their children are promoted to root level.
 */
function buildChartTree(rows, opts) {
    opts = opts || {};
    const idKey = opts.id_key || 'id';
    const parentKey = opts.parent_key || 'parent_id';
    const rankKey = opts.rank_key || 'rank';
    const orderKey = opts.order_key || 'display_order';
    const skipRanks = opts.skip_ranks || ['Super-Eon'];

    const byId = {};
    rows.forEach(r => { byId[r[idKey]] = { ...r, children: [] }; });

    const roots = [];
    rows.forEach(r => {
        const node = byId[r[idKey]];
        if (r[parentKey] && byId[r[parentKey]]) {
            const parent = byId[r[parentKey]];
            // Skip specified ranks: promote their children to root
            if (skipRanks.includes(parent[rankKey])) {
                roots.push(node);
            } else {
                parent.children.push(node);
            }
        } else if (!r[parentKey]) {
            // No parent — could be a skipped rank or actual root
            if (skipRanks.includes(r[rankKey])) {
                // Don't add skipped rank itself; its children will be promoted
            } else {
                roots.push(node);
            }
        }
    });

    // Sort children by order_key ascending
    function sortChildren(node) {
        node.children.sort((a, b) => (a[orderKey] || 0) - (b[orderKey] || 0));
        node.children.forEach(sortChildren);
    }
    roots.sort((a, b) => (a[orderKey] || 0) - (b[orderKey] || 0));
    roots.forEach(sortChildren);

    return roots;
}

/**
 * Compute leaf count for each node (= rowspan).
 * A leaf node (no children) has leafCount = 1.
 */
function computeLeafCount(node) {
    if (node.children.length === 0) {
        node.leafCount = 1;
        return 1;
    }
    let count = 0;
    node.children.forEach(c => { count += computeLeafCount(c); });
    node.leafCount = count;
    return count;
}

/**
 * Check if a node has a direct child at the next rank column (for colspan calculation).
 * e.g., Period (col 2) checking if any child is Sub-Period (col 3).
 */
function hasDirectChildRank(node, parentCol, rankColMap, rankKey) {
    return node.children.some(c => rankColMap[c[rankKey]] === parentCol + 1);
}

/**
 * Collect leaf rows via DFS. Each leaf produces one table row.
 * path = array of { node, col, colspan, rowspan } for ancestors that start at this leaf's row.
 * parentEndCol = the first column after the parent's span (used to detect gaps like Pridoli)
 * rankColMap = rank→column index mapping from chart_options
 */
function collectLeafRows(node, ancestorPath, leafRows, parentEndCol, rankColMap, opts) {
    opts = opts || {};
    const rankKey = opts.rank_key || 'rank';
    const maxCol = Object.keys(rankColMap).length - 1; // last rank column index

    let col = rankColMap[node[rankKey]] !== undefined ? rankColMap[node[rankKey]] : maxCol;

    // If node has children but no direct child at col+1, extend colspan to bridge the gap
    let colspan = 1;
    if (node.children.length > 0 && !hasDirectChildRank(node, col, rankColMap, rankKey)) {
        const childCols = node.children.map(c => rankColMap[c[rankKey]]).filter(c => c !== undefined);
        if (childCols.length > 0) {
            const minChildCol = Math.min(...childCols);
            if (minChildCol > col + 1) {
                colspan = minChildCol - col;
            }
        }
    }

    // Adjust for parent-child column gap (e.g., Pridoli: Age directly under Period)
    if (parentEndCol !== undefined && col > parentEndCol) {
        const originalEndCol = col + colspan - 1;
        col = parentEndCol;
        colspan = originalEndCol - col + 1;
    }

    const entry = { node, col, colspan, rowspan: node.leafCount };
    const myEndCol = col + colspan;

    if (node.children.length === 0) {
        // Leaf: extend colspan to fill remaining columns up to last rank column
        const endCol = col + colspan - 1;
        if (endCol < maxCol) {
            colspan = maxCol - col + 1; // extend to last rank col inclusive
            entry.colspan = colspan;
        }

        // Build the row: ancestor cells + this cell
        const row = [...ancestorPath, entry];
        leafRows.push(row);
    } else {
        // Non-leaf: first child inherits this node in its path, rest don't
        node.children.forEach((child, i) => {
            if (i === 0) {
                collectLeafRows(child, [...ancestorPath, entry], leafRows, myEndCol, rankColMap, opts);
            } else {
                collectLeafRows(child, [], leafRows, myEndCol, rankColMap, opts);
            }
        });
    }
}

/**
 * Determine if a hex color is light (for text contrast)
 */
function isLightColor(hex) {
    if (!hex) return true;
    hex = hex.replace('#', '');
    if (hex.length === 3) hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
    const r = parseInt(hex.substr(0, 2), 16);
    const g = parseInt(hex.substr(2, 2), 16);
    const b = parseInt(hex.substr(4, 2), 16);
    // Luminance formula
    const lum = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
    return lum > 0.5;
}

/**
 * Render the ICS chart as an HTML table (manifest-driven)
 */
function renderChartHTML(leafRows, opts) {
    opts = opts || {};
    const rankColumns = opts.rank_columns || [
        {rank: 'Eon', label: 'Eon'}, {rank: 'Era', label: 'Era'},
        {rank: 'Period', label: 'System / Period'}, {rank: 'Sub-Period', label: 'Sub-Period'},
        {rank: 'Epoch', label: 'Series / Epoch'}, {rank: 'Age', label: 'Stage / Age'}
    ];
    const valueCol = opts.value_column || {key: 'start_mya', label: 'Age (Ma)'};
    const cellClick = opts.cell_click || {detail_view: 'chronostrat_detail', id_key: 'id'};
    const labelKey = opts.label_key || 'name';
    const colorKey = opts.color_key || 'color';
    const idKey = opts.id_key || 'id';

    const headers = rankColumns.map(rc => rc.label).concat(valueCol.label);

    let html = '<table class="ics-chart"><thead><tr>';
    headers.forEach(h => { html += `<th>${h}</th>`; });
    html += '</tr></thead><tbody>';

    leafRows.forEach(row => {
        html += '<tr>';
        // Render ancestor + leaf cells
        row.forEach(entry => {
            const n = entry.node;
            const bgColor = n[colorKey] || '#f8f9fa';
            const textColor = isLightColor(bgColor) ? '#222' : '#fff';
            const rs = entry.rowspan > 1 ? ` rowspan="${entry.rowspan}"` : '';
            const cs = entry.colspan > 1 ? ` colspan="${entry.colspan}"` : '';
            const vk = valueCol.key;
            const title = n[vk] != null ? `${n[labelKey]} (${n[vk]}–${n.end_mya || 0} Ma)` : n[labelKey];
            html += `<td${rs}${cs} style="background-color:${bgColor}; color:${textColor};" `
                  + `title="${title}" onclick="openDetail('${cellClick.detail_view}', ${n[cellClick.id_key || idKey]})">`
                  + `${n[labelKey]}</td>`;
        });

        // Value column: use the leaf node's value
        const leaf = row[row.length - 1].node;
        const ageMa = leaf[valueCol.key] != null ? leaf[valueCol.key] : '';
        html += `<td class="ics-age">${ageMa}</td>`;

        html += '</tr>';
    });

    html += '</tbody></table>';
    return html;
}

/**
 * Build nested tree from flat rows using parent_key.
 */
function buildTreeFromFlat(rows, opts) {
    const idKey = opts.id_key || 'id';
    const parentKey = opts.parent_key || 'parent_id';

    const byId = {};
    rows.forEach(r => { byId[r[idKey]] = { ...r, children: [] }; });

    const roots = [];
    rows.forEach(r => {
        const node = byId[r[idKey]];
        const pid = r[parentKey];
        if (pid && byId[pid]) {
            byId[pid].children.push(node);
        } else if (!pid) {
            roots.push(node);
        }
    });

    // Sort children alphabetically by label
    const labelKey = opts.label_key || 'name';
    function sortChildren(node) {
        node.children.sort((a, b) => (a[labelKey] || '').localeCompare(b[labelKey] || ''));
        node.children.forEach(sortChildren);
    }
    roots.sort((a, b) => (a[labelKey] || '').localeCompare(b[labelKey] || ''));
    roots.forEach(sortChildren);

    return roots;
}

/**
 * Load taxonomy tree from manifest source_query (flat data → client-side tree)
 */
async function loadTree() {
    const container = document.getElementById('tree-container');

    try {
        // Use manifest source_query if available, otherwise fallback
        let tree;
        const viewDef = manifest && manifest.views && manifest.views['taxonomy_tree'];
        if (viewDef && viewDef.source_query && viewDef.tree_options) {
            const rows = await fetchQuery(viewDef.source_query);
            tree = buildTreeFromFlat(rows, viewDef.tree_options);
        } else {
            throw new Error('No manifest tree definition found');
        }
        container.innerHTML = '';

        tree.forEach(node => {
            container.appendChild(createTreeNode(node));
        });
    } catch (error) {
        container.innerHTML = `<div class="text-danger">Error loading tree: ${error.message}</div>`;
    }
}

/**
 * Create tree node element recursively (manifest-driven)
 */
function createTreeNode(node) {
    const div = document.createElement('div');
    div.className = 'tree-node';

    const opts = (manifest && manifest.views && manifest.views['taxonomy_tree'] &&
                  manifest.views['taxonomy_tree'].tree_options) || {};
    const leafRank = opts.leaf_rank || 'Family';
    const rankKey = opts.rank_key || 'rank';
    const labelKey = opts.label_key || 'name';
    const countKey = opts.count_key || 'genera_count';
    const idKey = opts.id_key || 'id';

    const hasChildren = node.children && node.children.length > 0;
    const isLeaf = node[rankKey] === leafRank;

    // Node content
    const content = document.createElement('div');
    content.className = `tree-node-content rank-${node[rankKey]}`;
    content.dataset.id = node[idKey];
    content.dataset.rank = node[rankKey];
    content.dataset.name = node[labelKey];

    // Toggle icon
    const toggle = document.createElement('span');
    toggle.className = 'tree-toggle';
    if (hasChildren) {
        toggle.innerHTML = '<i class="bi bi-chevron-down"></i>';
    }
    content.appendChild(toggle);

    // Folder/File icon
    const icon = document.createElement('span');
    icon.className = 'tree-icon';
    if (isLeaf) {
        icon.innerHTML = '<i class="bi bi-folder-fill"></i>';
    } else {
        icon.innerHTML = '<i class="bi bi-folder2"></i>';
    }
    content.appendChild(icon);

    // Label
    const label = document.createElement('span');
    label.className = 'tree-label';
    label.textContent = node[labelKey];
    content.appendChild(label);

    // Count (for leaf nodes)
    if (isLeaf && node[countKey] > 0) {
        const count = document.createElement('span');
        count.className = 'tree-count';
        count.textContent = `(${node[countKey]})`;
        content.appendChild(count);
    }

    // Info icon — detail view from manifest
    const infoBtn = document.createElement('span');
    infoBtn.className = 'tree-info';
    infoBtn.innerHTML = '<i class="bi bi-info-circle"></i>';
    infoBtn.title = 'View details';
    infoBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const infoOpts = opts.on_node_info || {};
        openDetail(infoOpts.detail_view || 'rank_detail', node[infoOpts.id_key || idKey]);
    });
    content.appendChild(infoBtn);

    // Click handler
    content.addEventListener('click', (e) => {
        if (hasChildren) {
            // Toggle children visibility
            const children = div.querySelector('.tree-children');
            if (children) {
                children.classList.toggle('collapsed');
                const chevron = toggle.querySelector('i');
                chevron.className = children.classList.contains('collapsed')
                    ? 'bi bi-chevron-right'
                    : 'bi bi-chevron-down';
            }
        }

        if (isLeaf) {
            selectTreeLeaf(node[idKey], node[labelKey]);
        }
    });

    div.appendChild(content);

    // Children container
    if (hasChildren) {
        const childrenDiv = document.createElement('div');
        childrenDiv.className = 'tree-children';

        node.children.forEach(child => {
            childrenDiv.appendChild(createTreeNode(child));
        });

        div.appendChild(childrenDiv);
    }

    return div;
}

/**
 * Select a tree leaf node and load its items (manifest-driven)
 */
async function selectTreeLeaf(leafId, leafName) {
    // Update selection highlight
    document.querySelectorAll('.tree-node-content.selected').forEach(el => {
        el.classList.remove('selected');
    });
    document.querySelector(`.tree-node-content[data-id="${leafId}"]`)?.classList.add('selected');

    selectedFamilyId = leafId;

    const opts = (manifest && manifest.views && manifest.views['taxonomy_tree'] &&
                  manifest.views['taxonomy_tree'].tree_options) || {};
    const filterDef = opts.item_valid_filter || {};

    // Update header with filter checkbox
    const header = document.getElementById('list-header');
    header.innerHTML = `
        <div class="d-flex justify-content-between align-items-center">
            <h5 class="mb-0"><i class="bi bi-folder-fill"></i> ${leafName}</h5>
            <div class="form-check">
                <input class="form-check-input" type="checkbox" id="validOnlyCheck"
                       ${showOnlyValid ? 'checked' : ''} onchange="toggleValidFilter()">
                <label class="form-check-label" for="validOnlyCheck">${filterDef.label || 'Valid only'}</label>
            </div>
        </div>`;

    // Load items via named query from manifest
    const container = document.getElementById('list-container');
    container.innerHTML = '<div class="loading">Loading genera...</div>';

    try {
        let items;
        if (opts.item_query && opts.item_param) {
            const baseUrl = API_BASE + `/api/queries/${opts.item_query}/execute`;
            const url = `${baseUrl}?${opts.item_param}=${leafId}`;
            const response = await fetch(url);
            if (!response.ok) throw new Error('Failed to load items');
            const data = await response.json();
            items = data.rows;
        } else {
            throw new Error('No manifest item query defined');
        }

        currentGenera = items;  // Store for filtering
        renderTreeItemTable();

    } catch (error) {
        container.innerHTML = `<div class="text-danger">Error loading genera: ${error.message}</div>`;
    }
}

/** Legacy alias for backward compatibility (used by navigateToRank, navigateToGenus) */
function selectFamily(familyId, familyName) {
    selectTreeLeaf(familyId, familyName);
}

/**
 * Toggle valid-only filter
 */
function toggleValidFilter() {
    showOnlyValid = document.getElementById('validOnlyCheck').checked;
    renderTreeItemTable();
}

/**
 * Render tree leaf item table with current filter (manifest-driven columns)
 */
function renderTreeItemTable() {
    const container = document.getElementById('list-container');

    const opts = (manifest && manifest.views && manifest.views['taxonomy_tree'] &&
                  manifest.views['taxonomy_tree'].tree_options) || {};
    const filterDef = opts.item_valid_filter || {};
    const filterKey = filterDef.key || 'is_valid';
    const columns = opts.item_columns || [
        {key: 'name', label: 'Genus', italic: true},
        {key: 'author', label: 'Author'},
        {key: 'year', label: 'Year'},
        {key: 'type_species', label: 'Type Species', truncate: 40},
        {key: 'location', label: 'Location', truncate: 30}
    ];
    const clickDef = opts.on_item_click || {detail_view: 'genus_detail', id_key: 'id'};
    const idKey = opts.id_key || 'id';

    const genera = showOnlyValid
        ? currentGenera.filter(g => g[filterKey])
        : currentGenera;

    if (genera.length === 0) {
        const message = showOnlyValid && currentGenera.length > 0
            ? `No valid genera (${currentGenera.length} invalid)`
            : 'No genera found in this family';
        container.innerHTML = `
            <div class="empty-state">
                <i class="bi bi-inbox"></i>
                <p>${message}</p>
            </div>`;
        return;
    }

    // Count stats
    const validCount = currentGenera.filter(g => g[filterKey]).length;
    const invalidCount = currentGenera.length - validCount;
    const statsText = showOnlyValid
        ? `Showing ${validCount} valid genera` + (invalidCount > 0 ? ` (${invalidCount} invalid hidden)` : '')
        : `Showing all ${currentGenera.length} genera (${validCount} valid, ${invalidCount} invalid)`;

    let html = `<div class="genera-stats text-muted mb-2">${statsText}</div>`;
    html += '<table class="genus-table"><thead><tr>';
    columns.forEach(col => { html += `<th>${col.label}</th>`; });
    html += '</tr></thead><tbody>';

    genera.forEach(g => {
        const rowClass = g[filterKey] ? '' : 'invalid';
        html += `<tr class="${rowClass}" onclick="openDetail('${clickDef.detail_view}', ${g[clickDef.id_key || idKey]})">`;
        columns.forEach(col => {
            let val = g[col.key];
            if (col.truncate && val) val = truncate(val, col.truncate);
            if (val == null) val = '';
            if (col.italic) {
                html += `<td class="genus-name"><i>${val}</i></td>`;
            } else {
                html += `<td>${val}</td>`;
            }
        });
        html += '</tr>';
    });

    html += '</tbody></table>';
    container.innerHTML = html;
}

/**
 * Expand tree path to a specific node and highlight it
 */
function expandTreeToNode(nodeId) {
    const nodeContent = document.querySelector(`.tree-node-content[data-id="${nodeId}"]`);
    if (!nodeContent) return;

    // Walk up DOM to expand all collapsed parent containers
    let element = nodeContent.parentElement;
    while (element) {
        if (element.classList && element.classList.contains('tree-children') && element.classList.contains('collapsed')) {
            element.classList.remove('collapsed');
            const parentContent = element.previousElementSibling;
            if (parentContent) {
                const chevron = parentContent.querySelector('.tree-toggle i');
                if (chevron) chevron.className = 'bi bi-chevron-down';
            }
        }
        element = element.parentElement;
    }

    // Highlight the node
    document.querySelectorAll('.tree-node-content.selected').forEach(el => {
        el.classList.remove('selected');
    });
    nodeContent.classList.add('selected');
    nodeContent.scrollIntoView({ behavior: 'smooth', block: 'center' });
}

/**
 * Navigate to a non-Genus rank from children list
 */
function navigateToRank(rankId, rankName, rankType) {
    expandTreeToNode(rankId);
    if (rankType === 'Family') {
        selectFamily(rankId, rankName);
    }
    openDetail('rank_detail', rankId);
}

/**
 * Navigate to a Genus from children list
 */
function navigateToGenus(genusId, familyId, familyName) {
    expandTreeToNode(familyId);
    selectFamily(familyId, familyName);
    openDetail('genus_detail', genusId);
}

/**
 * Expand all tree nodes
 */
function expandAll() {
    document.querySelectorAll('.tree-children.collapsed').forEach(el => {
        el.classList.remove('collapsed');
    });
    document.querySelectorAll('.tree-toggle i').forEach(el => {
        el.className = 'bi bi-chevron-down';
    });
}

/**
 * Collapse all tree nodes
 */
function collapseAll() {
    document.querySelectorAll('.tree-children').forEach(el => {
        el.classList.add('collapsed');
    });
    document.querySelectorAll('.tree-toggle i').forEach(el => {
        el.className = 'bi bi-chevron-right';
    });
}

/**
 * Build temporal range HTML with ICS mapping links
 */
function buildTemporalRangeHTML(g) {
    if (!g.temporal_code) return '-';
    let html = `<code>${g.temporal_code}</code>`;
    if (g.temporal_ics_mapping && g.temporal_ics_mapping.length > 0) {
        const links = g.temporal_ics_mapping.map(m =>
            `<a class="detail-link" onclick="openDetail('chronostrat_detail', ${m.id})">${m.name}</a>` +
            (m.mapping_type !== 'exact' ? ` <small class="text-muted">(${m.mapping_type})</small>` : '')
        ).join(', ');
        html += ` → ${links}`;
    }
    return html;
}

/**
 * Build hierarchy HTML for genus detail (Class → Order → ... → Family)
 */
function buildHierarchyHTML(g) {
    if (g.hierarchy && g.hierarchy.length > 0) {
        return g.hierarchy.map(h =>
            `<a class="detail-link" onclick="openDetail('rank_detail', ${h.id})">${h.name}</a>` +
            ` <small class="text-muted">(${h.rank})</small>`
        ).join(' → ');
    }
    return g.family_name || g.family || '-';
}

/**
 * Truncate text with ellipsis
 */
function truncate(text, maxLength) {
    if (!text) return '';
    return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
}

/**
 * Build the static HTML for the annotation section (form + placeholder for list)
 */
function buildAnnotationSectionHTML(entityType, entityId) {
    return `
        <div class="annotation-section" id="annotation-section-${entityType}-${entityId}">
            <h6>My Notes</h6>
            <div id="annotation-list-${entityType}-${entityId}">
                <div class="loading">Loading notes...</div>
            </div>
            <div class="annotation-form mt-2">
                <div class="mb-2">
                    <select class="form-select form-select-sm" id="annotation-type-${entityType}-${entityId}">
                        <option value="note">Note</option>
                        <option value="correction">Correction</option>
                        <option value="alternative">Alternative</option>
                        <option value="link">Link</option>
                    </select>
                </div>
                <div class="mb-2">
                    <textarea class="form-control form-control-sm" id="annotation-content-${entityType}-${entityId}"
                              rows="2" placeholder="Add a note..."></textarea>
                </div>
                <div class="d-flex gap-2">
                    <input type="text" class="form-control form-control-sm" id="annotation-author-${entityType}-${entityId}"
                           placeholder="Author (optional)" style="max-width: 200px;">
                    <button class="btn btn-sm btn-outline-primary"
                            onclick="addAnnotation('${entityType}', ${entityId})">Add</button>
                </div>
            </div>
        </div>`;
}

/**
 * Load annotations for an entity and render them
 */
async function loadAnnotations(entityType, entityId) {
    const listContainer = document.getElementById(`annotation-list-${entityType}-${entityId}`);
    if (!listContainer) return;

    try {
        const annUrl = API_BASE + `/api/annotations/${entityType}/${entityId}`;
        const response = await fetch(annUrl);
        const annotations = await response.json();

        if (annotations.length === 0) {
            listContainer.innerHTML = '<p class="text-muted mb-0" style="font-size:0.85rem;">No notes yet.</p>';
            return;
        }

        let html = '';
        annotations.forEach(a => {
            const typeBadge = {
                'note': 'bg-info',
                'correction': 'bg-warning text-dark',
                'alternative': 'bg-success',
                'link': 'bg-primary'
            }[a.annotation_type] || 'bg-secondary';

            html += `
                <div class="annotation-item">
                    <div class="d-flex justify-content-between align-items-start">
                        <div>
                            <span class="badge ${typeBadge}" style="font-size:0.7rem;">${a.annotation_type}</span>
                            ${a.author ? `<small class="text-muted ms-1">${a.author}</small>` : ''}
                            <small class="text-muted ms-1">${a.created_at}</small>
                        </div>
                        <button class="btn btn-sm btn-outline-danger" style="padding:0 4px; font-size:0.7rem;"
                                onclick="deleteAnnotation(${a.id}, '${entityType}', ${entityId})">
                            <i class="bi bi-x"></i>
                        </button>
                    </div>
                    <div style="margin-top:4px; font-size:0.9rem;">${a.content}</div>
                </div>`;
        });

        listContainer.innerHTML = html;
    } catch (error) {
        listContainer.innerHTML = `<div class="text-danger" style="font-size:0.85rem;">Error loading notes.</div>`;
    }
}

/**
 * Add a new annotation
 */
async function addAnnotation(entityType, entityId) {
    const contentEl = document.getElementById(`annotation-content-${entityType}-${entityId}`);
    const typeEl = document.getElementById(`annotation-type-${entityType}-${entityId}`);
    const authorEl = document.getElementById(`annotation-author-${entityType}-${entityId}`);

    const content = contentEl.value.trim();
    if (!content) return;

    try {
        const postUrl = API_BASE + '/api/annotations';
        const response = await fetch(postUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                entity_type: entityType,
                entity_id: entityId,
                annotation_type: typeEl.value,
                content: content,
                author: authorEl.value.trim() || null
            })
        });

        if (response.ok) {
            contentEl.value = '';
            loadAnnotations(entityType, entityId);
        }
    } catch (error) {
        // Silent fail
    }
}

/**
 * Delete an annotation
 */
async function deleteAnnotation(annotationId, entityType, entityId) {
    try {
        const delUrl = API_BASE + `/api/annotations/${annotationId}`;
        const response = await fetch(delUrl, {
            method: 'DELETE'
        });

        if (response.ok) {
            loadAnnotations(entityType, entityId);
        }
    } catch (error) {
        // Silent fail
    }
}


// ═══════════════════════════════════════════════════════════════════════
// Generic Manifest-Driven Detail Renderer (Phase 39)
// ═══════════════════════════════════════════════════════════════════════

/**
 * Open a detail view by manifest key. Dispatches to renderDetailFromManifest.
 */
async function openDetail(viewKey, entityId) {
    if (!manifest || !manifest.views[viewKey]) return;
    await renderDetailFromManifest(viewKey, entityId);
}

/**
 * Resolve a dotted path (e.g., "parent.name") on a data object.
 */
function resolveDataPath(data, path) {
    if (!data || !path) return undefined;
    return path.split('.').reduce((obj, key) => (obj != null ? obj[key] : undefined), data);
}

/**
 * Check a condition against data. Supports:
 *  - string key: truthy check (arrays check length > 0)
 *  - falsy/missing condition: always true
 */
function checkCondition(data, condition) {
    if (!condition) return true;
    const val = resolveDataPath(data, condition);
    if (Array.isArray(val)) return val.length > 0;
    return !!val;
}

/**
 * Build the modal title from a title_template and data.
 */
function buildDetailTitle(template, data) {
    if (!template || !template.format) return data.name || '';
    let title = template.format;
    // Replace {icon} with Bootstrap icon
    if (template.icon) {
        title = title.replace('{icon}', `<i class="bi ${template.icon}"></i>`);
    } else {
        title = title.replace('{icon}', '');
    }
    // Replace {field} placeholders
    title = title.replace(/\{(\w+)\}/g, (match, key) => {
        const val = data[key];
        return (val != null && val !== '') ? val : '';
    });
    return title.trim();
}

/**
 * Compute a derived value. Built-in compute functions.
 */
function computeValue(computeName, data, row) {
    const src = row || data;
    switch (computeName) {
        case 'time_range':
            if (src.start_mya != null && src.end_mya != null)
                return `${src.start_mya} — ${src.end_mya} Ma`;
            return '-';
        default:
            return '-';
    }
}

/**
 * Format a cell value according to field definition.
 */
function formatFieldValue(field, value, data) {
    const fmt = field.format;

    if (fmt === 'computed') {
        value = computeValue(field.compute, data);
    }

    if (value == null || value === '') {
        // For boolean, treat null/undefined as false
        if (fmt === 'boolean') return field.false_label || 'No';
        return '-';
    }

    switch (fmt) {
        case 'italic':
            return `<i>${value}</i>`;
        case 'boolean': {
            const cls = value ? '' : (field.false_class || '');
            const label = value ? (field.true_label || 'Yes') : (field.false_label || 'No');
            return cls ? `<span class="${cls}">${label}</span>` : label;
        }
        case 'link': {
            const linkDef = field.link;
            if (!linkDef) return value;
            const linkId = resolveDataPath(data, linkDef.id_path || linkDef.id_key);
            if (linkId == null) return value;
            return `<a class="detail-link" onclick="openDetail('${linkDef.detail_view}', ${linkId})">${value}</a>`;
        }
        case 'color_chip':
            return `<span class="color-chip" style="background-color:${value}"></span> ${value}`;
        case 'code':
            return `<code>${value}</code>`;
        case 'hierarchy':
            return buildHierarchyHTML(data);
        case 'temporal_range':
            return buildTemporalRangeHTML(data);
        case 'computed':
            return value; // already computed above
        default:
            return value;
    }
}

/**
 * Render a field_grid section.
 */
function renderFieldGrid(section, data) {
    const fields = section.fields || [];
    let gridHtml = '';

    for (const field of fields) {
        // Per-field condition check
        if (field.condition && !checkCondition(data, field.condition)) continue;

        let value = resolveDataPath(data, field.key);
        let formatted = formatFieldValue(field, value, data);

        // Suffix support (e.g., year + year_suffix)
        if (field.suffix_key) {
            const suffix = resolveDataPath(data, field.suffix_key);
            if (suffix) {
                if (field.suffix_format) {
                    formatted += ` <small class="text-muted">${field.suffix_format.replace('{value}', suffix)}</small>`;
                } else {
                    formatted += suffix;
                }
            }
        }

        gridHtml += `
            <span class="detail-label">${field.label}:</span>
            <span class="detail-value">${formatted}</span>`;
    }

    if (!gridHtml) return '';
    return `
        <div class="detail-section">
            <h6>${section.title}</h6>
            <div class="detail-grid">${gridHtml}
            </div>
        </div>`;
}

/**
 * Render a linked_table section.
 */
function renderLinkedTable(section, data) {
    const rows = data[section.data_key] || [];
    const columns = section.columns || [];
    const onClick = section.on_row_click;
    const title = section.title.replace('{count}', rows.length);

    // Empty handling
    if (rows.length === 0) {
        if (section.show_empty) {
            return `
                <div class="detail-section">
                    <h6>${title}</h6>
                    <p class="text-muted">${section.empty_message || 'No data.'}</p>
                </div>`;
        }
        return '';
    }

    // Header
    let html = `
        <div class="detail-section">
            <h6>${title}</h6>
            <div class="genera-list">
                <table class="manifest-table">
                    <thead><tr>`;
    columns.forEach(col => {
        html += `<th>${col.label}</th>`;
    });
    html += '</tr></thead><tbody>';

    // Rows
    rows.forEach(row => {
        const clickAttr = onClick
            ? ` onclick="openDetail('${onClick.detail_view}', ${row[onClick.id_key]})"`
            : '';
        html += `<tr${clickAttr}>`;

        columns.forEach(col => {
            let val = (col.format === 'computed')
                ? computeValue(col.compute, data, row)
                : row[col.key];

            // Column-level link (e.g., region link within genera table)
            if (col.link && val) {
                const linkId = row[col.link.id_key];
                if (linkId != null) {
                    val = `<a class="detail-link" onclick="event.stopPropagation(); openDetail('${col.link.detail_view}', ${linkId})">${val}</a>`;
                }
            } else if (col.format === 'boolean') {
                val = val ? 'Yes' : 'No';
            } else if (col.format === 'color_chip') {
                val = val ? `<span class="color-chip" style="background-color:${val}"></span> ${val}` : '';
            } else if (col.format === 'code') {
                val = val ? `<code>${val}</code>` : '';
            } else if (col.italic) {
                val = val ? `<i>${val}</i>` : '';
            } else {
                val = val != null ? val : '';
            }

            html += `<td>${val}</td>`;
        });

        html += '</tr>';
    });

    html += '</tbody></table></div></div>';
    return html;
}

/**
 * Render a tagged_list section (badge + text items).
 */
function renderTaggedList(section, data) {
    const items = data[section.data_key] || [];
    if (items.length === 0) return '';

    let html = `
        <div class="detail-section">
            <h6>${section.title}</h6>
            <ul class="list-unstyled">`;

    items.forEach(item => {
        const badge = item[section.badge_key] || '';
        const text = item[section.text_key] || '';
        const badgeHtml = section.badge_format === 'code'
            ? `<code>${badge}</code>`
            : `<span class="badge bg-secondary">${badge}</span>`;
        html += `<li>${badgeHtml} <small class="text-muted ms-1">(${text})</small></li>`;
    });

    html += '</ul></div>';
    return html;
}

/**
 * Render a raw_text section (monospace or paragraph).
 */
function renderRawText(section, data) {
    const value = data[section.data_key];
    if (!value) return '';

    const inner = section.format === 'paragraph'
        ? `<p>${value}</p>`
        : `<div class="raw-entry">${value}</div>`;

    return `
        <div class="detail-section">
            <h6>${section.title}</h6>
            ${inner}
        </div>`;
}

/**
 * Render an annotations section (My Notes with CRUD).
 */
function renderAnnotationsSection(section, data) {
    let entityType;
    if (section.entity_type) {
        entityType = section.entity_type;
    } else if (section.entity_type_from) {
        entityType = (data[section.entity_type_from] || '').toLowerCase();
    }
    if (!entityType) return '';
    return buildAnnotationSectionHTML(entityType, data.id);
}

/**
 * Built-in renderer: genus geography section.
 * Handles locations/formations with country/region links, fallback to raw text.
 */
function renderGenusGeography(data) {
    let geoGridHtml = '';

    if (data.locations && data.locations.length > 0) {
        const locLinks = data.locations.map(l => {
            let link = `<a class="detail-link" onclick="openDetail('country_detail', ${l.country_id})">${l.country_name}</a>`;
            if (l.region_id && l.region_name) {
                link += ` &gt; <a class="detail-link" onclick="openDetail('region_detail', ${l.region_id})">${l.region_name}</a>`;
            }
            return link;
        }).join(', ');
        geoGridHtml += `
            <span class="detail-label">Country:</span>
            <span class="detail-value">${locLinks}</span>`;
    } else if (data.location) {
        geoGridHtml += `
            <span class="detail-label">Location:</span>
            <span class="detail-value">${data.location}</span>`;
    }

    if (data.formations && data.formations.length > 0) {
        const fmtLinks = data.formations.map(f =>
            `<a class="detail-link" onclick="openDetail('formation_detail', ${f.id})">${f.name}</a>${f.period ? ' (' + f.period + ')' : ''}`
        ).join(', ');
        geoGridHtml += `
            <span class="detail-label">Formation:</span>
            <span class="detail-value">${fmtLinks}</span>`;
    } else if (data.formation) {
        geoGridHtml += `
            <span class="detail-label">Formation:</span>
            <span class="detail-value">${data.formation}</span>`;
    }

    if (!geoGridHtml) return '';
    return `
        <div class="detail-section">
            <h6>Geographic Information</h6>
            <div class="detail-grid">${geoGridHtml}
            </div>
        </div>`;
}

/**
 * Built-in renderer: synonym list section.
 */
function renderSynonymList(section, data) {
    const synonyms = data[section.data_key] || [];
    if (synonyms.length === 0) return '';

    let html = `
        <div class="detail-section">
            <h6>Synonymy</h6>
            <ul class="list-unstyled">`;

    synonyms.forEach(s => {
        const seniorLink = s.senior_taxon_id
            ? `<a href="#" class="synonym-link" onclick="openDetail('genus_detail', ${s.senior_taxon_id}); return false;"><i>${s.senior_name}</i></a>`
            : `<i>${s.senior_name}</i>`;
        html += `
            <li>
                <span class="badge bg-secondary badge-synonym">${s.synonym_type}</span>
                ${seniorLink}
                ${s.fide_author ? `<small class="text-muted">fide ${s.fide_author}${s.fide_year ? ', ' + s.fide_year : ''}</small>` : ''}
            </li>`;
    });

    html += '</ul></div>';
    return html;
}

/**
 * Built-in renderer: rank statistics section.
 */
function renderRankStatistics(data) {
    if (!data.genera_count && (!data.children_counts || data.children_counts.length === 0)) return '';

    let html = `
        <div class="detail-section">
            <h6>Statistics</h6>
            <div class="detail-grid">`;

    if (data.genera_count) {
        html += `
            <span class="detail-label">Genera:</span>
            <span class="detail-value">${data.genera_count}</span>`;
    }

    if (data.children_counts) {
        data.children_counts.forEach(c => {
            if (c.rank === 'Genus' && data.genera_count) return;
            html += `
                <span class="detail-label">${c.rank}:</span>
                <span class="detail-value">${c.count}</span>`;
        });
    }

    html += '</div></div>';
    return html;
}

/**
 * Built-in renderer: rank children list section.
 */
function renderRankChildren(section, data) {
    const children = data[section.data_key] || [];
    if (children.length === 0) return '';

    const title = `Children (${children.length}${children.length >= 20 ? '+' : ''})`;
    let html = `
        <div class="detail-section">
            <h6>${title}</h6>
            <ul class="list-unstyled children-list">`;

    children.forEach(c => {
        if (c.rank === 'Genus') {
            html += `
            <li class="clickable" onclick="navigateToGenus(${c.id}, ${data.id}, '${data.name.replace(/'/g, "\\'")}')">
                <span class="badge bg-light text-dark me-1">${c.rank}</span>
                <strong><i>${c.name}</i></strong>
                ${c.author ? '<small class="text-muted">' + c.author + '</small>' : ''}
            </li>`;
        } else {
            html += `
            <li class="clickable" onclick="navigateToRank(${c.id}, '${c.name.replace(/'/g, "\\'")}', '${c.rank}')">
                <span class="badge bg-light text-dark me-1">${c.rank}</span>
                <strong>${c.name}</strong>
                ${c.author ? '<small class="text-muted">' + c.author + '</small>' : ''}
            </li>`;
        }
    });

    html += '</ul></div>';
    return html;
}

/**
 * Dispatch section rendering by type.
 */
function renderDetailSection(section, data) {
    // Section-level condition check
    if (section.condition && !checkCondition(data, section.condition)) return '';

    switch (section.type) {
        case 'field_grid':      return renderFieldGrid(section, data);
        case 'linked_table':    return renderLinkedTable(section, data);
        case 'tagged_list':     return renderTaggedList(section, data);
        case 'raw_text':        return renderRawText(section, data);
        case 'annotations':     return renderAnnotationsSection(section, data);
        case 'genus_geography': return renderGenusGeography(data);
        case 'synonym_list':    return renderSynonymList(section, data);
        case 'rank_statistics': return renderRankStatistics(data);
        case 'rank_children':   return renderRankChildren(section, data);
        default:                return '';
    }
}

/**
 * Main entry point: render a detail view from manifest definition.
 */
async function renderDetailFromManifest(viewKey, entityId) {
    const view = manifest.views[viewKey];
    if (!view || view.type !== 'detail') return;

    const modalBody = document.getElementById('genusModalBody');
    const modalTitle = document.getElementById('genusModalTitle');

    modalBody.innerHTML = '<div class="loading">Loading...</div>';
    genusModal.show();

    try {
        const url = API_BASE + view.source.replace('{id}', entityId);
        const response = await fetch(url);
        const data = await response.json();

        // Title
        modalTitle.innerHTML = buildDetailTitle(view.title_template, data);

        // Sections
        let html = '';
        for (const section of view.sections) {
            html += renderDetailSection(section, data);
        }
        modalBody.innerHTML = html;

        // Post-render: load annotations for any annotations sections
        for (const section of view.sections) {
            if (section.type === 'annotations') {
                let entityType;
                if (section.entity_type) {
                    entityType = section.entity_type;
                } else if (section.entity_type_from) {
                    entityType = (data[section.entity_type_from] || '').toLowerCase();
                }
                if (entityType) {
                    loadAnnotations(entityType, data.id);
                }
            }
        }

    } catch (error) {
        modalBody.innerHTML = `<div class="text-danger">Error loading details: ${error.message}</div>`;
    }
}


// ═══════════════════════════════════════════════════════════════════════
// Global Search
// ═══════════════════════════════════════════════════════════════════════

/**
 * Escape HTML to prevent XSS
 */
function escapeHtml(str) {
    if (!str) return '';
    return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
}

// Search state
let searchIndex = null;  // { category: { rows, fields, ... } }
let searchIndexLoading = false;
let searchDebounceTimer = null;
let searchHighlightIndex = -1;
let searchResults = [];  // flat list of current results for keyboard nav
let searchExpandedCategories = {};  // track expanded "+N more" categories

const SEARCH_CATEGORIES = [
    {
        key: 'genera',
        query: 'genera_list',
        label: 'Genera',
        icon: 'bi-bug',
        fields: ['name', 'author', 'family'],
        displayField: 'name',
        displayItalic: true,
        metaFields: ['author', 'family'],
        detailView: 'genus_detail',
        idKey: 'id',
        defaultLimit: 6
    },
    {
        key: 'taxonomy',
        query: 'taxonomy_tree',
        label: 'Taxonomy',
        icon: 'bi-diagram-3',
        fields: ['name', 'rank'],
        displayField: 'name',
        metaFields: ['rank'],
        detailView: 'rank_detail',
        idKey: 'id',
        filterFn: row => row.rank !== 'Genus',
        defaultLimit: 4
    },
    {
        key: 'formations',
        query: 'formations_list',
        label: 'Formations',
        icon: 'bi-layers',
        fields: ['name', 'country', 'period'],
        displayField: 'name',
        metaFields: ['country', 'period'],
        detailView: 'formation_detail',
        idKey: 'id',
        defaultLimit: 4
    },
    {
        key: 'countries',
        query: 'countries_list',
        label: 'Countries',
        icon: 'bi-globe',
        fields: ['name'],
        displayField: 'name',
        metaFields: [],
        detailView: 'country_detail',
        idKey: 'id',
        defaultLimit: 4
    },
    {
        key: 'bibliography',
        query: 'bibliography_list',
        label: 'Bibliography',
        icon: 'bi-book',
        fields: ['authors', 'title'],
        displayField: 'authors',
        metaFields: ['title'],
        metaTruncate: 50,
        detailView: 'bibliography_detail',
        idKey: 'id',
        defaultLimit: 4
    },
    {
        key: 'chronostratigraphy',
        query: 'ics_chronostrat_list',
        label: 'Chronostratigraphy',
        icon: 'bi-clock-history',
        fields: ['name'],
        displayField: 'name',
        metaFields: ['rank'],
        detailView: 'chronostrat_detail',
        idKey: 'id',
        defaultLimit: 4
    }
];

/**
 * Initialize global search: event listeners, Ctrl+K shortcut, outside click
 */
function initGlobalSearch() {
    const input = document.getElementById('global-search-input');
    const resultsEl = document.getElementById('global-search-results');
    if (!input || !resultsEl) return;

    // Input event with debounce
    input.addEventListener('input', () => {
        clearTimeout(searchDebounceTimer);
        searchDebounceTimer = setTimeout(() => {
            performSearch(input.value);
        }, 200);
    });

    // Keyboard navigation
    input.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowDown') {
            e.preventDefault();
            moveSearchHighlight(1);
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            moveSearchHighlight(-1);
        } else if (e.key === 'Enter') {
            e.preventDefault();
            selectSearchHighlight();
        } else if (e.key === 'Escape') {
            e.preventDefault();
            hideSearchResults();
            input.blur();
        }
    });

    // Ctrl+K shortcut
    document.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
            e.preventDefault();
            input.focus();
            input.select();
        }
    });

    // Outside click closes dropdown
    document.addEventListener('click', (e) => {
        const container = document.querySelector('.global-search-container');
        if (container && !container.contains(e.target)) {
            hideSearchResults();
        }
    });
}

/**
 * Preload search index: fetch all 6 named queries in parallel
 */
async function preloadSearchIndex() {
    if (searchIndex || searchIndexLoading) return;
    searchIndexLoading = true;

    searchIndex = {};

    const promises = SEARCH_CATEGORIES.map(async (cat) => {
        try {
            let rows = await fetchQuery(cat.query);

            // Apply category filter if defined
            if (cat.filterFn) {
                rows = rows.filter(cat.filterFn);
            }

            // Pre-compute _searchText for fast matching
            rows.forEach(row => {
                row._searchText = cat.fields
                    .map(f => (row[f] || ''))
                    .join(' ')
                    .toLowerCase();
            });

            searchIndex[cat.key] = rows;
        } catch (e) {
            searchIndex[cat.key] = [];
        }
    });

    await Promise.all(promises);
    searchIndexLoading = false;
}

/**
 * Perform search across all categories
 */
function performSearch(query) {
    const resultsEl = document.getElementById('global-search-results');
    if (!resultsEl) return;

    query = (query || '').trim();

    if (query.length < 2) {
        hideSearchResults();
        return;
    }

    // Show loading if index not ready
    if (!searchIndex) {
        resultsEl.innerHTML = '<div class="search-status"><i class="bi bi-hourglass-split"></i> Building search index...</div>';
        resultsEl.classList.add('visible');
        // Retry after index loads
        if (!searchIndexLoading) preloadSearchIndex();
        setTimeout(() => performSearch(query), 300);
        return;
    }

    const terms = query.toLowerCase().split(/\s+/).filter(t => t.length > 0);
    searchResults = [];
    searchHighlightIndex = -1;
    searchExpandedCategories = {};

    let html = '';
    let totalResults = 0;

    SEARCH_CATEGORIES.forEach(cat => {
        const rows = searchIndex[cat.key] || [];

        // Multi-term AND matching
        let matches = rows.filter(row =>
            terms.every(term => row._searchText.includes(term))
        );

        if (matches.length === 0) return;

        // Sort: prefix match on display field first, then alphabetical
        const firstTerm = terms[0];
        matches.sort((a, b) => {
            const aName = (a[cat.displayField] || '').toLowerCase();
            const bName = (b[cat.displayField] || '').toLowerCase();
            const aPrefix = aName.startsWith(firstTerm) ? 0 : 1;
            const bPrefix = bName.startsWith(firstTerm) ? 0 : 1;
            if (aPrefix !== bPrefix) return aPrefix - bPrefix;
            return aName.localeCompare(bName);
        });

        totalResults += matches.length;

        // Category header
        html += `<div class="search-category-header">
            <i class="bi ${cat.icon}"></i> ${cat.label}
            <span class="search-cat-count">${matches.length}</span>
        </div>`;

        // Show limited results
        const limit = cat.defaultLimit;
        const visible = matches.slice(0, limit);
        const remaining = matches.length - limit;

        visible.forEach(row => {
            const idx = searchResults.length;
            searchResults.push({ cat, row });
            html += renderSearchResultItem(cat, row, terms, idx);
        });

        // "+N more" expander
        if (remaining > 0) {
            const catKey = cat.key;
            html += `<div class="search-more-item" data-cat="${catKey}" onclick="expandSearchCategory('${catKey}', this)">+${remaining} more</div>`;
            // Store hidden results for expansion
            searchExpandedCategories[catKey] = { matches: matches.slice(limit), cat, startIdx: searchResults.length };
        }
    });

    if (totalResults === 0) {
        html = '<div class="search-status">No results found</div>';
    }

    resultsEl.innerHTML = html;
    resultsEl.classList.add('visible');
}

/**
 * Render a single search result item
 */
function renderSearchResultItem(cat, row, terms, idx) {
    const displayVal = row[cat.displayField] || '';
    const highlighted = highlightTerms(escapeHtml(displayVal), terms);

    let mainHtml = cat.displayItalic
        ? `<i>${highlighted}</i>`
        : highlighted;

    let metaHtml = '';
    if (cat.metaFields && cat.metaFields.length > 0) {
        const metaParts = cat.metaFields
            .map(f => row[f] || '')
            .filter(v => v)
            .join(', ');
        if (metaParts) {
            let metaText = cat.metaTruncate ? truncate(metaParts, cat.metaTruncate) : metaParts;
            metaHtml = `<span class="search-result-meta">${escapeHtml(metaText)}</span>`;
        }
    }

    return `<div class="search-result-item" data-idx="${idx}"
                 onclick="onSearchResultClick(${idx})"
                 onmouseenter="searchHighlightIndex=${idx}; updateSearchHighlight()">
        <span class="search-result-main">${mainHtml}</span>
        ${metaHtml}
    </div>`;
}

/**
 * Highlight search terms in text using <mark> tags
 */
function highlightTerms(escapedText, terms) {
    let result = escapedText;
    terms.forEach(term => {
        const escaped = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const regex = new RegExp(`(${escaped})`, 'gi');
        result = result.replace(regex, '<mark>$1</mark>');
    });
    return result;
}

/**
 * Expand a "+N more" category to show all results
 */
function expandSearchCategory(catKey, el) {
    const data = searchExpandedCategories[catKey];
    if (!data) return;

    const input = document.getElementById('global-search-input');
    const query = (input ? input.value : '').trim();
    const terms = query.toLowerCase().split(/\s+/).filter(t => t.length > 0);

    let html = '';
    data.matches.forEach(row => {
        const idx = searchResults.length;
        searchResults.push({ cat: data.cat, row });
        html += renderSearchResultItem(data.cat, row, terms, idx);
    });

    el.insertAdjacentHTML('afterend', html);
    el.remove();
    delete searchExpandedCategories[catKey];
}

/**
 * Handle search result click
 */
function onSearchResultClick(idx) {
    const item = searchResults[idx];
    if (!item) return;

    hideSearchResults();

    const id = item.row[item.cat.idKey];
    openDetail(item.cat.detailView, id);
}

/**
 * Move highlight up/down
 */
function moveSearchHighlight(delta) {
    if (searchResults.length === 0) return;

    searchHighlightIndex += delta;
    if (searchHighlightIndex < 0) searchHighlightIndex = searchResults.length - 1;
    if (searchHighlightIndex >= searchResults.length) searchHighlightIndex = 0;

    updateSearchHighlight();
}

/**
 * Update highlight visual
 */
function updateSearchHighlight() {
    const resultsEl = document.getElementById('global-search-results');
    if (!resultsEl) return;

    resultsEl.querySelectorAll('.search-result-item').forEach(el => {
        el.classList.toggle('highlighted', parseInt(el.dataset.idx) === searchHighlightIndex);
    });

    // Scroll into view
    const highlighted = resultsEl.querySelector('.search-result-item.highlighted');
    if (highlighted) {
        highlighted.scrollIntoView({ block: 'nearest' });
    }
}

/**
 * Select the currently highlighted result
 */
function selectSearchHighlight() {
    if (searchHighlightIndex >= 0 && searchHighlightIndex < searchResults.length) {
        onSearchResultClick(searchHighlightIndex);
    }
}

/**
 * Hide search results dropdown
 */
function hideSearchResults() {
    const resultsEl = document.getElementById('global-search-results');
    if (resultsEl) {
        resultsEl.classList.remove('visible');
    }
    searchHighlightIndex = -1;
}
    </script>
</body>
</html>
